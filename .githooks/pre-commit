#!/bin/bash
# Pre-commit hook for local-first validation
# Implements Phase 1 of shift-left CI/CD strategy

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Track overall status
EXIT_CODE=0

# Function to print colored output
print_header() {
    echo -e "\n${CYAN}═══════════════════════════════════════════════════════${NC}"
    echo -e "${CYAN}  Pre-Commit Validation (Shift-Left CI/CD)${NC}"
    echo -e "${CYAN}═══════════════════════════════════════════════════════${NC}\n"
}

print_status() {
    echo -e "${BLUE}[Check]${NC} $1"
}

print_success() {
    echo -e "${GREEN}[✓]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[!]${NC} $1"
}

print_error() {
    echo -e "${RED}[✗]${NC} $1"
}

print_info() {
    echo -e "${CYAN}[i]${NC} $1"
}

# Function to check if we're in a Git repository
check_git_repo() {
    if ! git rev-parse --git-dir > /dev/null 2>&1; then
        print_error "Not in a Git repository"
        exit 1
    fi
}

# Function to check if Mix is available
check_mix_available() {
    if ! command -v mix > /dev/null 2>&1; then
        print_error "Mix command not found - Elixir not installed?"
        print_info "Install Elixir: https://elixir-lang.org/install.html"
        exit 1
    fi
}

# Check 1: Code Formatting (Backend)
check_backend_formatting() {
    print_status "Checking backend code formatting..."

    # Get staged .ex and .exs files in backend/
    STAGED_EX_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep -E '^backend/.*\.(ex|exs)$' || true)

    if [ -z "$STAGED_EX_FILES" ]; then
        print_info "No backend Elixir files staged for commit"
        return 0
    fi

    # Change to backend directory
    cd backend

    # Check formatting only on staged files (strip 'backend/' prefix)
    FILES_TO_CHECK=$(echo "$STAGED_EX_FILES" | sed 's|^backend/||')
    FORMAT_CHECK=$(mix format --check-formatted $FILES_TO_CHECK 2>&1)

    # Return to root
    cd ..

    if echo "$FORMAT_CHECK" | grep -q "mix format"; then
        print_error "Some staged backend files are not formatted correctly"
        echo "$FORMAT_CHECK" | grep -v "^$"
        print_info "Run 'cd backend && mix format' to fix formatting issues"
        print_info "Or use 'git commit --no-verify' to skip this check (not recommended)"
        return 1
    else
        print_success "Backend code formatting is correct"
        return 0
    fi
}

# Check 2: Code Formatting (Frontend)
check_frontend_formatting() {
    print_status "Checking frontend code formatting..."

    # Get staged TypeScript/Svelte files in frontend/
    STAGED_TS_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep -E '^frontend/.*\.(ts|js|svelte)$' || true)

    if [ -z "$STAGED_TS_FILES" ]; then
        print_info "No frontend TypeScript/Svelte files staged for commit"
        return 0
    fi

    # Check if npm is available
    if ! command -v npm > /dev/null 2>&1; then
        print_warning "npm not found - skipping frontend formatting check"
        return 0
    fi

    # Change to frontend directory
    cd frontend

    # Check if node_modules exists
    if [ ! -d "node_modules" ]; then
        print_warning "Frontend dependencies not installed - skipping formatting check"
        print_info "Run 'cd frontend && npm install' to install dependencies"
        cd ..
        return 0
    fi

    # Run prettier check
    FORMAT_CHECK=$(npm run format:check 2>&1)
    FORMAT_STATUS=$?

    # Return to root
    cd ..

    if [ $FORMAT_STATUS -ne 0 ]; then
        print_error "Some staged frontend files are not formatted correctly"
        echo "$FORMAT_CHECK"
        print_info "Run 'cd frontend && npm run format' to fix formatting issues"
        print_info "Or use 'git commit --no-verify' to skip this check (not recommended)"
        return 1
    else
        print_success "Frontend code formatting is correct"
        return 0
    fi
}

# Check 3: Compilation (Backend)
check_compilation() {
    print_status "Checking backend compilation..."

    # Change to backend directory
    cd backend

    # Capture output and check exit code
    COMPILE_OUTPUT=$(MIX_ENV=dev mix compile 2>&1)
    COMPILE_STATUS=$?

    # Return to root
    cd ..

    if [ $COMPILE_STATUS -ne 0 ]; then
        print_error "Backend compilation failed"
        echo "$COMPILE_OUTPUT"
        print_info "Fix compilation errors before committing"
        print_info "Or use 'git commit --no-verify' to skip this check (not recommended)"
        return 1
    else
        # Check for warnings (compilation succeeds but with warnings)
        if echo "$COMPILE_OUTPUT" | grep -q "warning:"; then
            print_warning "Backend compilation succeeded but has warnings"
            echo "$COMPILE_OUTPUT" | grep "warning:"
            print_info "Consider fixing warnings before committing"
            # Don't fail on warnings, just notify
        else
            print_success "Backend compilation successful (no warnings)"
        fi
        return 0
    fi
}

# Check 4: Credo (Static Analysis)
check_credo() {
    print_status "Running static analysis (mix credo)..."

    # Change to backend directory
    cd backend

    # Check if Credo is available
    if ! mix help credo > /dev/null 2>&1; then
        print_warning "Credo not available - skipping static analysis"
        print_info "Run 'cd backend && mix deps.get' to install Credo"
        cd ..
        return 0
    fi

    # Run Credo - only fail on design and consistency issues
    CREDO_OUTPUT=$(mix credo --only design,consistency --format oneline 2>&1)
    CREDO_STATUS=$?

    # Return to root
    cd ..

    if [ $CREDO_STATUS -ne 0 ]; then
        print_error "Credo found design or consistency issues"
        echo "$CREDO_OUTPUT"
        print_info "Fix issues or use 'git commit --no-verify' to skip"
        return 1
    else
        # Check if there are any issues
        if echo "$CREDO_OUTPUT" | grep -q "┃"; then
            ISSUE_COUNT=$(echo "$CREDO_OUTPUT" | grep -c "┃")
            print_warning "Credo found $ISSUE_COUNT design/consistency issues"
            echo "$CREDO_OUTPUT"
            print_info "Consider addressing issues before committing"
            # Don't fail, just notify
        else
            print_success "Static analysis passed (no critical issues)"
        fi
        return 0
    fi
}

# Check 5: Ash Framework Migration Detection
check_ash_codegen() {
    print_status "Checking Ash resource migrations..."

    # Change to backend directory
    cd backend

    # Check if Ash is available
    if ! mix help ash.codegen > /dev/null 2>&1; then
        print_warning "Ash not available - skipping migration check"
        cd ..
        return 0
    fi

    # Check for pending Ash migrations
    ASH_OUTPUT=$(mix ash.codegen --check 2>&1)
    ASH_STATUS=$?

    # Return to root
    cd ..

    if [ $ASH_STATUS -ne 0 ]; then
        # Check if it's actually a pending migration issue
        if echo "$ASH_OUTPUT" | grep -q "would generate"; then
            print_error "Ash resource changes detected without migrations"
            echo "$ASH_OUTPUT"
            print_info "Run 'cd backend && mix ash.codegen' to generate required migrations"
            print_info "Then run 'mix ash_postgres.migrate' to apply them"
            print_info "Or use 'git commit --no-verify' to skip this check (not recommended)"
            return 1
        else
            # Some other Ash error - show but don't fail
            print_warning "Ash codegen check had issues (see output)"
            echo "$ASH_OUTPUT"
            return 0
        fi
    else
        print_success "No pending Ash migrations"
        return 0
    fi
}

# Check 6: Frontend Type Checking
check_frontend_types() {
    print_status "Checking frontend TypeScript types..."

    # Get staged TypeScript files in frontend/
    STAGED_TS_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep -E '^frontend/.*\.ts$' || true)

    if [ -z "$STAGED_TS_FILES" ]; then
        print_info "No TypeScript files staged for commit"
        return 0
    fi

    # Check if npm is available
    if ! command -v npm > /dev/null 2>&1; then
        print_warning "npm not found - skipping type checking"
        return 0
    fi

    # Change to frontend directory
    cd frontend

    # Check if node_modules exists
    if [ ! -d "node_modules" ]; then
        print_warning "Frontend dependencies not installed - skipping type check"
        print_info "Run 'cd frontend && npm install' to install dependencies"
        cd ..
        return 0
    fi

    # Run TypeScript check
    TYPE_CHECK=$(npm run check 2>&1)
    TYPE_STATUS=$?

    # Return to root
    cd ..

    if [ $TYPE_STATUS -ne 0 ]; then
        print_error "Frontend type checking failed"
        echo "$TYPE_CHECK"
        print_info "Fix type errors before committing"
        print_info "Or use 'git commit --no-verify' to skip this check (not recommended)"
        return 1
    else
        print_success "Frontend type checking passed"
        return 0
    fi
}

# Check 7: Sensitive Information in Markdown Files
check_md_sensitive_info() {
    print_status "Checking markdown files for sensitive information..."

    # Get staged .md files
    STAGED_MD_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep -E '\.md$' || true)

    if [ -z "$STAGED_MD_FILES" ]; then
        print_info "No markdown files staged for commit"
        return 0
    fi

    FOUND_ISSUES=0

    # Patterns that suggest sensitive information
    # Each pattern: "regex|||description"
    PATTERNS=(
        'password\s*[:=]\s*["\x27][^"\x27]{4,}'|||'Possible password value'
        'secret_key_base\s*[:=]\s*["\x27][^"\x27]{8,}'|||'Possible SECRET_KEY_BASE value'
        'ELECTRIC_SECRET\s*[:=]\s*["\x27][^"\x27]{4,}'|||'Possible ELECTRIC_SECRET value'
        'SHARED_TOKEN_SECRET\s*[:=]\s*["\x27][^"\x27]{4,}'|||'Possible SHARED_TOKEN_SECRET value'
        'Bearer\s+ey[A-Za-z0-9_-]{20,}'|||'Possible JWT token'
        'POSTGRES_PASSWORD\s*=\s*[^\s$]{4,}'|||'Possible database password (not variable ref)'
        'api[_-]?key\s*[:=]\s*["\x27][^"\x27]{8,}'|||'Possible API key value'
        'ghp_[A-Za-z0-9]{36,}'|||'GitHub personal access token'
        'sk-[A-Za-z0-9]{20,}'|||'Possible secret key (sk-...)'
    )

    for PATTERN_DESC in "${PATTERNS[@]}"; do
        PATTERN="${PATTERN_DESC%%|||*}"
        DESC="${PATTERN_DESC##*|||}"

        for FILE in $STAGED_MD_FILES; do
            # Search staged content (not working tree)
            MATCHES=$(git diff --cached -U0 "$FILE" 2>/dev/null | grep -iP "^\+.*${PATTERN}" || true)
            if [ -n "$MATCHES" ]; then
                if [ $FOUND_ISSUES -eq 0 ]; then
                    print_error "Potential sensitive information found in markdown files:"
                fi
                FOUND_ISSUES=1
                echo -e "  ${RED}${FILE}${NC}: ${DESC}"
                echo "$MATCHES" | head -3 | sed 's/^/    /'
            fi
        done
    done

    if [ $FOUND_ISSUES -ne 0 ]; then
        print_info "Review the flagged lines above. If they are example/template values, use 'git commit --no-verify'"
        return 1
    else
        print_success "No sensitive information detected in markdown files"
        return 0
    fi
}

# Function to get list of staged files
get_staged_files() {
    git diff --cached --name-only --diff-filter=ACM
}

# Main execution
main() {
    print_header

    # Initial checks
    check_git_repo
    check_mix_available

    # Get staged files
    STAGED_FILES=$(get_staged_files)

    if [ -z "$STAGED_FILES" ]; then
        print_warning "No files staged for commit"
        print_info "Use 'git add <files>' to stage changes"
        exit 0
    fi

    print_info "Running pre-commit checks on staged files..."
    echo ""

    # Run all checks
    check_backend_formatting || EXIT_CODE=1
    echo ""

    check_frontend_formatting || EXIT_CODE=1
    echo ""

    check_compilation || EXIT_CODE=1
    echo ""

    check_credo || EXIT_CODE=1
    echo ""

    check_ash_codegen || EXIT_CODE=1
    echo ""

    check_frontend_types || EXIT_CODE=1
    echo ""

    check_md_sensitive_info || EXIT_CODE=1
    echo ""

    # Final result
    echo -e "${CYAN}═══════════════════════════════════════════════════════${NC}"

    if [ $EXIT_CODE -eq 0 ]; then
        print_success "All pre-commit checks passed!"
        echo -e "${CYAN}═══════════════════════════════════════════════════════${NC}\n"
        exit 0
    else
        print_error "Pre-commit checks failed"
        print_info "Fix the issues above and try again"
        print_warning "To bypass: git commit --no-verify (not recommended)"
        echo -e "${CYAN}═══════════════════════════════════════════════════════${NC}\n"
        exit 1
    fi
}

# Run main function
main
