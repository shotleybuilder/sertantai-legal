# Issue #2: Populate enacting field from enacted_by reverse relationships

**Started**: 2025-12-24 ~00:45
**Issue**: https://github.com/shotleybuilder/sertantai-legal/issues/2

## Todo
- [x] Review existing enacted_by implementation in staged_parser
- [x] Import existing Airtable `Enacted_by` and `Enacting (from LRT)` data
- [x] Set is_enacting flag on parent laws
- [x] Extend affected_laws.json to track enacting_parents
- [x] Extend Storage.add_affected_laws to accept enacted_by list
- [x] Update ScrapeController.confirm to pass enacted_by to Storage
- [x] Add batch_update_enacting endpoint (direct array update, not re-parse)
- [x] Extend CascadeUpdateModal to show enacting parents section
- [x] Add "Update Enacting Links" button to modal

## Notes
- enacted_by: child → parent (already implemented in EnactedBy module)
- enacting: parent → children (reverse relationship)
- Only secondary legislation has enacted_by values
- Primary legislation (Acts) are the enablers

## Work Completed

### Airtable Import (2025-12-24)
- Created `scripts/data/update_uk_lrt_enacting.exs`
- Imported from CSV columns:
  - `Enacted_by` → `enacted_by`
  - `Enacting (from LRT)` → `enacting`
- Results:
  - enacted_by: 8,378 records
  - enacting: 686 records
  - is_enacting flag: 686 records

### Database Backup
- `~/Documents/sertantai_data/sertantai_legal_dev_20251224.sql` (98MB)

## Cascade Update Design

### Key Difference: Amending vs Enacting

| Aspect | Amending/Rescinding | Enacting |
|--------|---------------------|----------|
| When new law has | `amending: [law1, law2]` | `enacted_by: [parent1]` |
| Affected laws | law1, law2 need amended_by updated | parent1 needs enacting updated |
| Update method | **Re-parse** (fetch from legislation.gov.uk) | **Direct update** (array append) |
| Why | amended_by comes from /changes/affected | enacting is derived, not scraped |

### Extended affected_laws.json Structure

```
{
  entries: [
    {
      source_law: "uksi/2025/123",
      amending: ["ukpga/2020/1"],      // Laws this SI amends
      rescinding: [],
      enacted_by: ["ukpga/1974/37"],   // NEW: Parent laws
      added_at: "2025-12-24T..."
    }
  ],
  all_amending: ["ukpga/2020/1"],       // Need re-parse
  all_rescinding: [],                    // Need re-parse
  all_enacting_parents: ["ukpga/1974/37"] // NEW: Need direct update
}
```

### CascadeUpdateModal Sections

1. **Laws to Re-parse** (existing)
   - Laws in `all_amending` + `all_rescinding`
   - Action: Re-parse via StagedParser to update amended_by/rescinded_by

2. **Parent Laws to Update** (new)
   - Laws in `all_enacting_parents`
   - Action: Direct array append - add source_law(s) to parent's `enacting`
   - Also set `is_enacting: true` on parent

### API Endpoint

```
POST /sessions/:id/update-enacting-links
Body: { names: ["ukpga/1974/37"] }  // Optional, defaults to all

Response: {
  session_id: "...",
  total: 1,
  success: 1,
  errors: 0,
  results: [{ name: "ukpga/1974/37", status: "success", added: ["uksi/2025/123"] }]
}
```

### Implementation Flow

1. User persists new SI with `enacted_by: ["ukpga/1974/37"]`
2. `Storage.add_affected_laws` records parent in `all_enacting_parents`
3. Modal shows "Parent Laws to Update: 1"
4. User clicks "Update Enacting Links"
5. Backend finds source laws for each parent, appends to `enacting` array
6. Sets `is_enacting: true` on parent

## Implementation Complete (2025-12-24)

### Backend Changes
- **storage.ex**: Extended `add_affected_laws/5` to accept `enacted_by` list, track `all_enacting_parents`
- **scrape_controller.ex**:
  - Updated `confirm` to pass `enacted_by` to Storage
  - Extended `affected_laws` response with enacting parents data
  - Added `update_enacting_links` endpoint for direct array updates
- **router.ex**: Added `POST /sessions/:id/update-enacting-links` route

### Frontend Changes
- **scraper.ts**: Added `EnactingParentLaw` interface, extended `AffectedLawsResult`, added `updateEnactingLinks` function
- **CascadeUpdateModal.svelte**:
  - Added purple-themed enacting parents section
  - Shows parent laws with current enacting count
  - "Update Enacting Selected" and "Update All Parents" buttons
  - Results display showing success/unchanged/error status

### Key Files
- `backend/lib/sertantai_legal/scraper/storage.ex`
- `backend/lib/sertantai_legal_web/controllers/scrape_controller.ex`
- `backend/lib/sertantai_legal_web/router.ex`
- `frontend/src/lib/api/scraper.ts`
- `frontend/src/lib/components/CascadeUpdateModal.svelte`

### Tests
- All 299 backend tests pass (added 27 tests for cascade update workflow)

### enacted_by Refactor (b42a475)
- Phase 1-3 complete, pushed to main
- Pattern Registry with 9 patterns (5 specific_act, 3 powers_clause, 1 footnote_fallback)
- Matcher behaviour + 3 matcher modules
- Metrics module for visibility into pattern matching

### Pattern Improvements (cd0c1da)
- Inline Citation extraction (c00001 refs in addition to f00001)
- EU regulation URL support (eur/YYYY/NNNN)
- SI amendment filtering (only primary legislation can "enact")
- Full enacting clause extraction (all refs, not just first)
- Building Act 1984 added to specific_act patterns
- Verified on 3 test cases:
  - Building Safety Levy → ukpga/1984/55, ukpga/2022/30
  - Biocidal Products → eur/2012/0528
  - Wet Wipes → ukpga/1990/43, ukpga/2008/13

## Future Work: enacted_by Parser Improvements

### Current State
The `enacted_by` parser in `EnactedBy` module uses regex patterns to extract enabling Act references from secondary legislation XML. This is a mixed bag because there is no standardized way enacted_by is described in secondary law.

**File**: `backend/lib/sertantai_legal/scraper/enacted_by.ex`

### Current Architecture (3 Strategies)

The code uses a cascade of 3 strategies:

1. **`find_specific_enacting_clauses/1`** (lines 182-204)
   - Hardcoded patterns for 4 specific Acts:
     - Transport and Works Act 1992 (`ukpga/1992/42`)
     - European Union (Withdrawal) Act 2018 (`ukpga/2018/16`)
     - Planning Act 2008 (`ukpga/2008/29`)
     - Health and Safety at Work etc. Act 1974 (`ukpga/1974/37`)
   - Returns immediately if matched

2. **`find_powers_conferred_by/2`** (lines 207-228)
   - Generic patterns: "powers conferred by", "powers under", "in exercise of the powers"
   - Captures footnote refs (e.g., `f00001`) and looks up URLs in footnote map
   - Extracts law IDs from legislation.gov.uk URLs

3. **`extract_laws_from_footnotes/2`** (lines 231-254)
   - Fallback when strategies 1 & 2 find nothing
   - Extracts all footnote refs from text
   - Filters to URLs containing years mentioned in text
   - Last resort, broader net

### Issues with Current Design

| Issue | Description |
|-------|-------------|
| **Hardcoded patterns** | 4 Acts baked into code at lines 183-194 |
| **Not extensible** | Adding a pattern requires code changes |
| **No visibility** | Can't see patterns or match rates without reading code |
| **Mixed abstractions** | Specific patterns (Act names) mixed with generic (footnote extraction) |
| **No metrics** | No tracking of which patterns match or fail |
| **Tight coupling** | Pattern matching coupled to business logic |

### Architectural Recommendations

#### 1. Pattern Registry Pattern
Define patterns as **data**, not code. Patterns should be:
- Stored in a configuration module or external config
- Loadable at runtime
- Easily addable without touching core logic

```elixir
# Example: Pattern as data
%{
  id: :hswa_1974,
  name: "Health and Safety at Work etc. Act 1974",
  type: :regex,
  pattern: ~r/Health and Safety at Work etc\.? Act 1974/i,
  output: "ukpga/1974/37",
  priority: 100,
  category: :specific_act
}
```

#### 2. Pattern Types
Support multiple pattern types with different matchers:

| Type | Description | Example |
|------|-------------|---------|
| `:exact_act` | Specific Act name → specific ID | "Planning Act 2008" → ukpga/2008/29 |
| `:regex` | Regex pattern → extract ID | `/section \d+ of the (\w+ Act \d{4})/` |
| `:footnote` | Footnote ref → URL lookup | `f00001` → legislation.gov.uk URL |
| `:structural` | XML structure-based | `//EnactingText//Citation/@URI` |

#### 3. Pattern Pipeline
Process patterns in priority order, with early exit or accumulation:

```
┌─────────────────┐
│ Input: XML text │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ High-priority   │ ──▶ Match? ──▶ Return
│ specific Acts   │
└────────┬────────┘
         │ No match
         ▼
┌─────────────────┐
│ Medium-priority │ ──▶ Match? ──▶ Return
│ generic regex   │
└────────┬────────┘
         │ No match
         ▼
┌─────────────────┐
│ Low-priority    │ ──▶ Return (even if empty)
│ fallback/heuristic│
└─────────────────┘
```

#### 4. Proposed Module Structure

```
enacted_by/
├── enacted_by.ex           # Main API (unchanged interface)
├── pattern_registry.ex     # Pattern definitions as data
├── matchers/
│   ├── exact_act.ex        # Matches specific Act names
│   ├── regex.ex            # Generic regex patterns
│   ├── footnote.ex         # Footnote URL extraction
│   └── structural.ex       # XML structure-based
└── metrics.ex              # Optional: track match rates
```

#### 5. Benefits of Refactor

| Benefit | Description |
|---------|-------------|
| **Extensibility** | Add patterns via config, not code |
| **Testability** | Test each pattern independently |
| **Visibility** | List all patterns, see match rates |
| **Maintainability** | Clear separation of concerns |
| **Debugging** | Log which pattern matched each law |

### Implementation Approach

**Strategy: Refactor first, then analyze.** The metrics/visibility from the refactored code will naturally surface gaps and new patterns. Trying to analyze before refactoring means we'd need to re-analyze after anyway.

1. **Phase 1: Extract patterns to data** (low risk)
   - Move hardcoded patterns to `pattern_registry.ex`
   - Keep existing logic, just externalize data
   - Maintain backward compatibility

2. **Phase 2: Add pattern types & matchers** (medium risk)
   - Create matcher behaviour
   - Each pattern type has its own matcher module
   - Pipeline processes patterns by priority

3. **Phase 3: Add metrics & visibility**
   - Track which patterns match (and which don't)
   - Log pattern match rates
   - Surface unmatched laws for pattern expansion

### Phase 3 Detailed Plan: Batch Analysis & Metrics

**Goal**: Analyze enacted_by parsing across enriched laws from previous sessions to identify gaps and measure pattern coverage.

#### 3.1 Architecture

```
┌─────────────────────────────────────────────────────────────┐
│  /admin/scrape/enacted_by                                   │
├─────────────────────────────────────────────────────────────┤
│  EnactedByAnalysisController                                │
│    - GET /              → list analysis runs                │
│    - POST /analyze      → run new analysis on session(s)    │
│    - GET /:id           → view analysis results             │
│    - GET /:id/unmatched → view unmatched laws detail        │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│  EnactedBy.BatchAnalyzer                                    │
│    - analyze_session(session_id)                            │
│    - analyze_laws([law_names])                              │
│    - get_enriched_laws_from_session(session_id)             │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│  Storage: priv/scraper/enacted_by_analysis/                 │
│    - {timestamp}_analysis.json                              │
│    - Contains: metrics, matched, unmatched, by_pattern      │
└─────────────────────────────────────────────────────────────┘
```

#### 3.2 Data Source
Analyze **enriched laws from previous sessions**:
- Read from session's `inc_w_si.json` (parsed laws)
- Or query persisted `uk_lrt` records
- NOT the raw scraped laws (those aren't enriched yet)

#### 3.3 Metrics to Track

| Metric | Description |
|--------|-------------|
| `total_laws` | Number of laws analyzed |
| `matched_count` | Laws with at least one enacted_by found |
| `unmatched_count` | Laws with no enacted_by found |
| `match_rate` | Percentage of laws with matches |
| `by_strategy` | Breakdown by strategy (specific_act, powers_clause, fallback) |
| `by_pattern` | Count of matches per pattern ID |
| `by_type_code` | Breakdown by law type (uksi, ssi, wsi, etc.) |

#### 3.4 Persisted Results Structure

```json
{
  "id": "2025-12-24T12:00:00Z",
  "session_ids": ["session-1", "session-2"],
  "run_at": "2025-12-24T12:00:00Z",
  "summary": {
    "total_laws": 100,
    "matched_count": 85,
    "unmatched_count": 15,
    "match_rate": 0.85
  },
  "by_strategy": {
    "specific_act": 20,
    "powers_clause": 60,
    "fallback": 5
  },
  "by_pattern": {
    "hswa_1974": 15,
    "powers_conferred_by": 45,
    ...
  },
  "unmatched": [
    {"name": "uksi/2025/123", "enacting_text": "...", "type_code": "uksi"}
  ],
  "matched": [
    {"name": "uksi/2025/456", "enacted_by": ["ukpga/1990/43"], "strategy": "powers_clause"}
  ]
}
```

#### 3.5 Implementation Tasks
- [ ] Create `EnactedBy.BatchAnalyzer` module
- [ ] Create `EnactedByAnalysisController` with routes
- [ ] Add frontend page at `/admin/scrape/enacted_by`
- [ ] Persist results to JSON files
- [ ] Display unmatched laws for pattern expansion work

4. **Phase 4: Expand pattern registry**
   - Use metrics to identify gaps
   - Add new patterns based on real data
   - Iterate until coverage is acceptable

### Todo
- [X] Phase 1: Extract patterns to pattern_registry.ex
- [X] Phase 2: Implement matcher behaviour and pattern types
- [X] Phase 3a: Add basic metrics (find_enacting_laws_with_metrics, debug_match, pattern_summary)
- [ ] Phase 3b: Batch analysis script for pattern coverage
- [X] Phase 4a: Fix footnote ref extraction (include FootnoteRef in text)
- [X] Phase 4b: Add inline Citation extraction (c00001 refs)
- [X] Phase 4c: Add EU regulation URL support
- [X] Phase 4d: Filter SI amendment refs (only primary legislation as enacted_by)
- [X] Phase 4e: Extract ALL refs from enacting clause (not just first)
- [ ] Phase 4f: Run batch analysis to find remaining gaps
- [ ] Test expanded patterns against known laws
