# Issue #3: Function Field

**Started**: 2025-12-25
**Issue**: https://github.com/shotleybuilder/sertantai-legal/issues/3

## Todo
- [x] Create Function calculation module
- [x] Write migration script for existing records
- [x] Add calculate_function to scraper persist flow

## Implementation

### FunctionCalculator Module
`backend/lib/sertantai_legal/legal/function_calculator.ex`

**Full calculation:**
- `calculate_function_of_law/1` - Calculate function for single record
- `calculate_function_of_laws/1` - Batch calculation (single DB query for all targets)

**Staged calculation (for scraper workflow):**
- `calculate_immediate_function_of_law/1` - Just Making, Commencing (no DB lookup)
- `calculate_relationship_function_of_law/1` - Amending/Revoking/Enacting Maker (needs DB lookup)
- `calculate_relationship_function_of_laws/1` - Batch relationship calculation

**Persistence:**
- `calculate_and_persist_function_of_law/1` - Calculate and update DB by ID
- `calculate_and_persist_function_of_laws/1` - Batch calculate and persist
- `persist_function_of_law/2` - Persist pre-calculated function

**Enacting updates:**
- `add_child_to_enacting_of_parent_law/3` - Add child to parent's enacting[]
- `update_enacting_from_enacted_by_of_laws/1` - Batch update from enacted_by

Key features:
- Handles name format normalization (`uksi/2020/1` ↔ `UK_uksi_2020_1`)
- is_making/is_commencing now boolean (converted from decimal)
- Batch lookups for is_making of target laws
- 93.7% match rate against Airtable-imported function values

### Persister Integration
`backend/lib/sertantai_legal/scraper/persister.ex`

Function calculation follows three phases in `persist_records/1`:

1. **Phase 1 - Immediate**: Calculate Making, Commencing at persist time
2. **Phase 2 - Enacting**: Update parent's enacting[] from child's enacted_by
3. **Phase 3 - Relationship**: End-of-batch calc for Amending/Revoking Maker

### CSV Import Script (preferred for existing data)
`scripts/data/update_uk_lrt_function.exs`
- Imports Function values from Airtable CSV export
- Also sets is_making and is_commencing boolean flags
- Run: `mix run ../scripts/data/update_uk_lrt_function.exs`
- **Result**: 12,858 records updated from CSV

### Calculation Script (for recalculation)
`scripts/data/calculate_uk_lrt_function.exs`
- Options: `--all`, `--dry-run`, `--limit N`
- Used when CSV not available or for new laws

### Schema Fix
- Converted is_making and is_commencing from decimal to boolean
- Migration: `20251225075953_convert_is_making_to_boolean.exs`

### Database Backup
`~/Documents/sertantai_data/sertantai_legal_dev_20251225.sql` (98MB)

### Function Column Stats (2025-12-25)

| Column | Count |
|--------|-------|
| total_records | 19,089 |
| has_function | 12,858 |
| is_making = true | 3,186 |
| is_commencing = true | 1,504 |
| is_enacting = true | 686 |
| is_amending = true | 9,865 |
| is_rescinding = true | 2,458 |
| has enacting[] | 686 |
| has amending[] | 9,865 |
| has rescinding[] | 2,458 |

## Design Points

### 1. Function is Dynamic
- Function labels can change when underlying relationships change
- e.g., law gains new `amending` entries → Function needs "Amending" or "Amending Maker" added
- Recalc options:
  - **Automatic**: Trigger on field changes (amending, enacting, rescinding, is_making, is_commencing)
  - **Manual**: Button/endpoint to recalculate

### 2. Making Logic
- `is_making` in DB is pre-calculated from Airtable
- Core logic (not yet implemented in this app):
  - `duty_type` contains "Duty" OR "Responsibility"
  - OR `Makes? (Override)` = true (field not in this app)
  - OR `Packages` is truthy (can ignore)
- **For now**: Use existing `is_making` field as-is
- **Future**: When duty_type feature is added, recalculate is_making from duty_type

### 3. Maker vs Non-Maker Classification
- "Maker" = a law with `is_making = true` (creates duties/responsibilities)
- NOT based on type_code (primary vs secondary legislation)
- Requires DB lookup of each target law's `is_making` field

**Logic for each relationship (enacting, amending, rescinding):**
```
For Law A with enacting: [Law B, Law C, Law D]
  - Look up is_making for each target law
  - maker_count = count where is_making = true
  - non_maker_count = count where is_making = false/null

if non_maker_count > 0 AND maker_count > 0 → BOTH labels ("Enacting, Enacting Maker")
if maker_count > 0 only → just "Enacting Maker"
if non_maker_count > 0 only → just "Enacting"
```

**Example:**
- HSWA 1974 enacts 500 SIs
- 300 of those SIs have `is_making = true`
- 200 have `is_making = false`
- HSWA 1974 gets both "Enacting Maker" AND "Enacting"

### 4. UI Display - Colored Badges
Function displayed as colored pill badges:

| Label | Color |
|-------|-------|
| Enacting Maker | Dark green |
| Enacting | Light green |
| Amending Maker | Dark gray/brown |
| Amending | Light gray |
| Revoking Maker | Dark red/maroon |
| Revoking | Light red/pink |
| Making | Light blue |
| Commencing | Yellow (?) |

Badge order appears consistent: Enacting* → Amending* → Revoking* → Making

## Notes
- Function is a JSONB field with keys: Making, Amending, Amending Maker, Revoking, Revoking Maker, Enacting, Enacting Maker, Commencing
- "Maker" suffix = TARGET law has `is_making = true` (creates duties/responsibilities)
- No suffix = TARGET law has `is_making = false/null`
- 6,231 records missing function (of 19,089 total)
- 12,858 records have function from Airtable import

### Calculation Logic
1. **Making**: From `is_making` field (boolean)
2. **Commencing**: From `is_commencing` field (boolean)
3. **Enacting/Enacting Maker**: From `enacting` array - classify by target's `is_making`
4. **Amending/Amending Maker**: From `amending` array - classify by target's `is_making`
5. **Revoking/Revoking Maker**: From `rescinding` array - classify by target's `is_making`

---

## Scraper Integration: Static vs Dynamic Function Setting

### Relationship Field Directions

The scraper populates bidirectional relationship arrays:

| This Law Does Action | This Law Receives Action |
|---------------------|--------------------------|
| `amending[]` - laws this law amends | `amended_by[]` - laws that amend this law |
| `rescinding[]` - laws this law revokes | `rescinded_by[]` - laws that revoke this law |
| `enacting[]` - laws this law enables | `enacted_by[]` - parent enabling legislation |

**Key insight**: When a new SI is scraped with `enacted_by: ["parent"]`, the parent's `enacting[]` needs updating.

### When to Calculate Each Function Label

| Function Label | Source | Timing | Notes |
|----------------|--------|--------|-------|
| **Making** | `is_making` | IMMEDIATE | Determined by law's own properties |
| **Commencing** | `is_commencing` | IMMEDIATE | Determined by law's own content |
| **Amending** | `amending[]` | END OF BATCH | Base label from having amending[] |
| **Amending Maker** | `amending[]` | END OF BATCH | Targets' is_making may change during cascade |
| **Revoking** | `rescinding[]` | END OF BATCH | Base label from having rescinding[] |
| **Revoking Maker** | `rescinding[]` | END OF BATCH | Targets' is_making may change during cascade |
| **Enacting** | `enacting[]` | DYNAMIC | Parent's enacting[] grows as children are added |
| **Enacting Maker** | `enacting[]` | DYNAMIC | Recalc when new child added with is_making |

**Why end-of-batch for Amending/Revoking?**
- Cascade rescraping may update `is_making` on touched laws
- "Maker" suffix depends on current `is_making` of targets
- Must wait until all `is_making` updates complete

### Scraper Workflow for Function

**Relationship arrays are immutable once set:**
- `amending[]` / `rescinding[]` - set when THIS law is scraped (intrinsic to the law)
- We never mutate these arrays on other laws

**The problem:**
- `is_making` of TARGET laws can change during cascade rescraping
- "Maker" suffix depends on targets' current `is_making` values
- Therefore Maker calculation must happen AFTER all `is_making` updates

**Scraping Session Flow:**

```
1. SCRAPE NEW LAWS (e.g., new SIs)
   - Each new law gets amending[], rescinding[] from its own data
   - Calculate immediate Function labels:
     - Making (from is_making)
     - Commencing (from is_commencing)
   - DO NOT calculate Amending Maker / Rescinding Maker yet

2. CASCADE RESCRAPE (user-controlled, breadth-first)
   - Touched laws (those in amending[], rescinding[]) get rescraped
   - Their amended_by[], rescinded_by[] fields are updated
   - Their is_making may change (e.g., duty_type updated)

3. END OF BATCH: Calculate Maker Suffixes
   - For all laws in this session that have amending[]:
     - Lookup is_making of all targets in amending[]
     - Set "Amending" and/or "Amending Maker" labels
   - For all laws in this session that have rescinding[]:
     - Lookup is_making of all targets in rescinding[]
     - Set "Revoking" and/or "Revoking Maker" labels
```

**Order of operations:**
```
Session Start
    │
    ▼
Scrape new laws ──► Set Making, Commencing immediately
    │
    ▼
User triggers cascade rescrape
    │
    ▼
Touched laws rescraped ──► is_making may change
    │
    ▼
Session End: Batch calculate Amending/Rescinding Maker
             for all laws that touched others
```

**Enacting is different:**
- Parent's `enacting[]` grows over time as new children are scraped
- When child declares `enacted_by: ["parent"]`:
  - Update parent's `enacting[]` to include child
  - Recalc parent's Enacting/Enacting Maker labels

### Implementation Tasks

- [ ] Separate Function calc into immediate (Making, Commencing) vs deferred (Maker suffixes)
- [ ] Track laws with amending[]/rescinding[] during session for batch recalc
- [ ] Add end-of-session batch Function recalc for Maker suffixes
- [ ] Handle enacting[] updates when child declares enacted_by

---

**Ended**: 2025-12-26

## Summary
- Completed: 3 of 3 todos
- Files touched: function_calculator.ex, persister.ex, uk_lrt.ex, migration, test.exs config
- Outcome: Implemented Function field calculation with staged workflow (immediate/end-of-batch/dynamic) integrated into scraper persist flow.
- Next: Issue complete. Consider adding tests for Function calculation edge cases.
