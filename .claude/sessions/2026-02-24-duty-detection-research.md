# Title: Duty/Responsibility Detection in UK LRT Laws

**Started**: 2026-02-24 08:00
**Ended**: 2026-02-24 11:45
**Context**: Taxa parsing is compute-intensive (Regex). New Rust+LanceDB+AI service exists. Connection should move to Zenoh. Key question: how to reliably detect if a law sets duties/responsibilities before full-text parsing.

## Issues Created
- **#24**: [data: Reconcile three conflicting vocabularies](https://github.com/shotleybuilder/sertantai-legal/issues/24)
- **#25**: [feat: Making/Maker detection at LRT parse stage](https://github.com/shotleybuilder/sertantai-legal/issues/25)

## Todo
- [x] Examine UK LRT schema for duty/responsibility indicators
- [x] Analyse existing data patterns (duty_holder, power_holder, rights_holder fields)
- [x] Research what distinguishes duty-setting laws from others
- [x] Identify reliable heuristics for pre-filtering
- [x] Document findings and recommendations
- [x] Untangle the Function field taxonomy muddle
- [x] Analyse duty_type smoking gun and three vocabulary systems
- [x] Create GitHub issues #24 and #25

---

## Research Findings

### 1. Current State of the Data (Actual DB vs Ash Resource vs Airtable)

There are **three different representations** of the Function taxonomy that have drifted apart:

| Source | `is_making` type | `function` type | Function vocabulary |
|--------|-----------------|-----------------|---------------------|
| **Airtable CSV** | N/A (derived) | Multi-select string | Making, Amending, Amending Maker, Revoking, Revoking Maker, Commencing, Enacting, Enacting Maker |
| **SQL dump** (from old sertantai DB) | `numeric(38,9)` | TEXT | Amendment, Commencement, Transitional, Revoke, Transfer, etc. |
| **Ash resource** (target schema) | `:boolean` | `:map` (JSONB) | Making, Amending, Amending Maker, Revoking, Revoking Maker, Commencing, Enacting, Enacting Maker |
| **Actual DB** (what's loaded now) | TEXT (`'Act'`, `'SI'`, empty) | TEXT (comma-separated) | Mix -- depends on which import path was run last |

### 2. How the Function Taxonomy Got Muddled

#### The Original Airtable Taxonomy (Source of Truth)

The Airtable `Function` column is a multi-select with exactly **8 base tags**:

| Tag | Meaning | Count (as tag) |
|-----|---------|---------------|
| **Making** | Creates new substantive duties/obligations | 3,186 records (16.3%) |
| **Amending** | Modifies existing legislation (targets are non-makers) | 7,420 (37.9%) |
| **Amending Maker** | Modifies existing legislation that IS a maker | 6,213 (31.7%) |
| **Revoking** | Repeals/revokes other laws (targets are non-makers) | 2,329 (11.9%) |
| **Revoking Maker** | Repeals/revokes other laws that ARE makers | 697 (3.6%) |
| **Commencing** | Brings other laws into force | 1,505 (7.7%) |
| **Enacting** | Primary legislation enabling SIs (targets are non-makers) | 622 (3.2%) |
| **Enacting Maker** | Primary legislation enabling SIs that ARE makers | 234 (1.2%) |

Key stats: 19,573 CSV records total, 12,860 with Function data, 6,713 empty. 107 unique tag combinations.

The **"Maker" suffix** is semantic and relational: it means "the TARGET law of this relationship has `Making` in its own Function". This creates a network view -- you can trace which amendments/revocations affect duty-creating laws vs procedural ones.

#### Import Path 1: The SQL Dump (Old Sertantai DB)

`uk_lrt_data.sql` was generated by `pg_dump` from the **old sertantai database** (PostgreSQL 14). This database had its own schema where:
- `is_making` was `numeric(38,9)` (Airtable export format for boolean -- `1.000000000`)
- `function` was plain TEXT with a **completely different vocabulary**: `Amendment`, `Commencement`, `Transitional`, `Revoke`, `Transfer`, `Saving`, `Applied`, `Extension`, `Modification`

This old vocabulary appears to come from an **earlier manual classification** that predates the Airtable multi-select taxonomy. It does NOT include "Making" as a function value -- instead the old system used `is_making` as a separate flag.

When `import_uk_lrt.sql` runs, it copies these old-format values directly into the Ash-migrated table, overwriting the JSONB column with TEXT values.

#### Import Path 2: The CSV Update Script

`scripts/data/update_uk_lrt_function.exs` reads the Airtable CSV and:
1. Parses `Function` as comma-separated string
2. Creates proper JSONB: `{"Making": true, "Amending": true, ...}`
3. Sets `is_making` = true/false (boolean) based on "Making" presence
4. Sets `is_commencing` = true/false based on "Commencing" presence
5. Matches records by `name` field

This correctly maps the Airtable taxonomy to the Ash schema.

#### Import Path 3: The Function Calculator

`backend/lib/sertantai_legal/legal/function_calculator.ex` can **recalculate** function from the relationship arrays (`amending[]`, `rescinding[]`, `enacting[]`) by looking up each target's `is_making` flag. This produces the same 8-tag taxonomy as Airtable but derived algorithmically.

#### The Collision

The muddle is that **the SQL dump and the CSV updater write to the same columns with incompatible formats**:

```
SQL dump writes:    function = 'Amendment'              (TEXT)
                    is_making = 1.000000000              (numeric)

CSV updater writes: function = {"Making": true, ...}    (JSONB)
                    is_making = true                     (boolean)
```

If you run `mix ash.setup` (creates Ash schema with JSONB/boolean types), then `import_uk_lrt.sql` (inserts old-format TEXT/numeric), you get a database where the Ash resource expects JSONB but the column contains TEXT. PostgreSQL will happily store either in a `jsonb` column (a bare string `'Amendment'` is valid JSON), but the JSONB `?` operator in `for_applicability_screening` won't work correctly against it.

The CSV updater (`update_uk_lrt_function.exs`) is designed to run AFTER the SQL import to overwrite the old-format values with proper JSONB. But:
- It only updates records where CSV `Name` matches DB `name`
- The CSV has 19,573 records vs DB's 19,089 (484 CSV records don't match)
- 6,713 CSV records have empty Function (left as whatever the SQL dump put there)

### 3. The Correct Taxonomy (What It Should Be)

The Airtable taxonomy IS the correct one and the Ash resource + FunctionCalculator both implement it correctly. The 8 tags decompose cleanly into:

**Base functions** (what the law does):
- **Making** -- creates substantive duties/obligations
- **Commencing** -- brings other laws into force
- **Amending** -- modifies other laws
- **Revoking** -- repeals/removes other laws
- **Enacting** -- enables secondary legislation

**"Maker" qualifiers** (what the TARGET does):
- **Amending Maker** -- amends a law that has Making
- **Revoking Maker** -- revokes a law that has Making
- **Enacting Maker** -- enables a law that has Making

A single law can have **multiple tags**: e.g., "Amending Maker, Amending, Making" means the law creates its own duties AND amends both maker and non-maker laws.

**For the duty-detection question**: a law needs taxa parsing if and only if `Making` is in its function tags.

### 4. What Needs Fixing

1. **The SQL dump is stale data from the old sertantai schema** -- it should not be the canonical import path. The canonical data is in Airtable (exported as CSV).

2. **`is_making` in the old dump means "is this an Act or SI"** (TEXT) -- completely different semantics from the Ash boolean "does this law create duties".

3. **The 6,713 records with empty Function in CSV** need classification. The FunctionCalculator can derive function from relationship arrays IF those arrays are populated. Otherwise title-based heuristics or the Rust/AI service are needed.

4. **After any SQL import, the CSV updater MUST be re-run** to convert old-format values to proper JSONB. Or better: create a new import pipeline that reads the CSV directly instead of going through the SQL dump.

### 5. Title-Based Detection Accuracy

Cross-referencing titles against function field (from old-format DB data):

| Title Signal | Correlation | Notes |
|-------------|-------------|-------|
| "(Amendment" in title | 83% of Amendments caught | But 1,292 false positives (title says amendment, function says otherwise) |
| "(Commencement" in title | 87.5% caught | 686 false positives |
| "(Revocation/Revoking" in title | 63.4% caught | Weakest signal |

**Title is useful for EXCLUSION but not for positive identification of duty-creating laws.**

### 6. Holder Data Pattern

Holder fields (duty_holder, power_holder, rights_holder) are populated **only** for records where the old-format `is_making` is set (Act/SI). Zero records have holders without `is_making`. This means the holders were populated at the family level -- inherited from the parent Act to all SIs in that family.

42 distinct duty holder roles. All three holder types tend to co-populate (4,553 have all three), but 1,458 have ONLY duty_holder. Pattern:
- 11,498 records: no holders at all
- 4,553: all three holder types
- 1,498: duty + power (no rights)
- 1,458: duty only

### 7. Practical Recommendation for Duty Detection

**For existing classified records (12,860 with Airtable Function):**
- `Making` in function tags -> needs taxa parsing (3,186 records, 16.3%)
- No `Making` -> skip taxa parsing

**For unclassified records (6,713 empty Function):**
Apply tiered pre-filter before sending to Rust/AI service:

1. **Title exclusion**: "(Commencement", "(Amendment)", "(Revocation)" in title -> skip
2. **Relationship derivation**: If `amending[]`, `rescinding[]`, `enacting[]` arrays are populated, run FunctionCalculator to derive function
3. **Metadata signals**: Fetch lightweight metadata from legislation.gov.uk (dc:subject, paragraph counts, AlternativeNumber)
4. **Survivors**: Send to Rust/AI service via Zenoh for full text analysis

**Estimated efficiency:** ~3,200 records (16%) need full parsing, ~16,400 (84%) can be excluded by function tags + title heuristics alone.

### 8. Architecture Note: Zenoh Connection

- Pre-filter runs locally in Elixir (fast, no network)
- Only survivors cross to Rust service via Zenoh
- Zenoh topic structure: `sertantai/legal/taxa/classify/{law_ref}` (request), `sertantai/legal/taxa/result/{law_ref}` (response)
- Gateway decision: `"Making" in function_tags` OR (unclassified AND survives title heuristics)

---

## Section: Untangling the Function Field Muddle

### The Core Problem

The `function` field has been written by **three different systems** with **three incompatible vocabularies**, and the database currently holds whichever one ran last.

### The Three Writers

#### Writer 1: The Old Sertantai Database (via pg_dump)

The original sertantai monolith had its own classification system where `function` was a **plain TEXT column** with values like:

```
Amendment                           (2,714 records)
Commencement                        (1,154)
Transitional                        (416)
Amendment,Revoke                    (100)
Revoke                              (74)
Transfer                            (53)
Amendment,Transfer                  (26)
Commencement,Saving                 (18)
...
(empty)                             (14,498)
```

And `is_making` was `numeric(38,9)` with Airtable's export format for booleans (1.000000000 / NULL). But somewhere in the old DB it got repurposed to store 'Act' or 'SI' as legislation type.

**This vocabulary is missing "Making" entirely** -- the old system's approach was: `is_making` flag (separate field) + `function` for everything EXCEPT making.

#### Writer 2: The Airtable CSV (via update_uk_lrt_function.exs)

Airtable's multi-select produces comma-separated strings like:
```
Making
Amending Maker,Amending
Amending Maker,Amending,Making
Commencing,Amending Maker,Amending
Amending Maker,Amending,Revoking,Making
```

The import script correctly converts these to JSONB maps:
```json
{"Making": true, "Amending Maker": true, "Amending": true}
```

This is the **canonical, correct vocabulary**: 8 tags, combinable, with "Maker" suffix indicating target law status.

#### Writer 3: The FunctionCalculator (algorithmically derived)

`function_calculator.ex` reconstructs the same 8-tag JSONB from relationship arrays + `is_making` lookups. It produces identical output to the CSV import but derived from data rather than manual tagging. It's designed to run for newly-scraped laws that weren't in the original Airtable.

### Why They Collide

The import sequence is:

```
1. mix ash.setup          → Creates table with JSONB function column, boolean is_making
2. import_uk_lrt.sql      → Inserts TEXT function values, numeric is_making FROM OLD DB
3. update_uk_lrt_function  → Overwrites with JSONB function, boolean is_making FROM CSV
```

Step 2 puts old-vocabulary TEXT into a JSONB column. Step 3 fixes it but only for records with CSV matches AND non-empty Function. The result:

- **12,860 records** get proper JSONB from CSV (if step 3 ran)
- **6,713 records** keep whatever step 2 put there (old TEXT format OR null)
- **484 records** in DB that don't match any CSV name (orphans from step 2)

### The `is_making` Field: Three Meanings

| Context | Type | Values | Meaning |
|---------|------|--------|---------|
| Old sertantai DB dump | numeric(38,9) | 1.000000000 / NULL | "Is this law a maker?" (boolean encoded as decimal) |
| Current DB (after SQL import) | TEXT | 'Act', 'SI', '' | "What type of legislation?" (completely different!) |
| Ash resource definition | boolean | true/false | "Does this law have Making function?" |
| CSV updater output | boolean | true/false | "Does Function contain Making?" |

The TEXT values 'Act'/'SI' in the current DB appear to come from a corrupted import -- possibly an Airtable formula field that returned the legislation type instead of the making flag, and this got dumped into the SQL.

### The Resolution

**The Airtable 8-tag taxonomy is correct and well-designed.** It captures both the law's own function AND its relationship to the maker network. The Ash resource + FunctionCalculator implement this taxonomy correctly. The problem is purely a data import ordering issue.

**To fix:**
1. Run `update_uk_lrt_function.exs` after any SQL import (it overwrites old-format values)
2. For the 6,713 records with empty Function in CSV: run FunctionCalculator to derive from relationships, or apply title-based heuristics, or send to Rust/AI service
3. Stop using `import_uk_lrt.sql` as the primary import path -- it carries stale old-format data
4. Consider a migration that validates function is proper JSONB (not bare TEXT) and is_making is boolean (not 'Act'/'SI')

### Airtable Function Tag Reference

For completeness, the 20 most common combinations from the CSV:

| Function combination | Count | Has Making? |
|---------------------|-------|-------------|
| (empty) | 6,713 | Unknown |
| Amending | 2,843 | No |
| Amending Maker | 1,802 | No |
| Amending Maker, Amending | 1,325 | No |
| **Making** | **1,183** | **Yes** |
| Amending, Revoking | 504 | No |
| **Amending Maker, Making** | **437** | **Yes** |
| Commencing, Amending Maker, Amending | 421 | No |
| **Amending Maker, Amending, Making** | **412** | **Yes** |
| Amending Maker, Amending, Revoking | 405 | No |
| Revoking | 384 | No |
| Commencing, Amending | 381 | No |
| Commencing | 347 | No |
| Commencing, Amending Maker | 317 | No |
| **Amending, Making** | **255** | **Yes** |
| **Amending Maker, Amending, Revoking, Making** | **174** | **Yes** |
| Enacting | 143 | No |
| Amending Maker, Revoking | 125 | No |
| **Revoking, Making** | **106** | **Yes** |
| **Amending Maker, Revoking, Making** | **97** | **Yes** |

**Total records with Making tag: 3,186 (16.3%)** -- these are the laws that need taxa parsing.

---

## Section: The duty_type Smoking Gun and the Three Vocabularies

### The Airtable `duty_type` Column is NOT What You Think

The Airtable CSV column called `duty_type` is **not** the same concept as the Ash resource `duty_type` field. It is a **combined multi-select** that merges two completely different taxonomies into one field:

**Purpose tags** (what the SECTION does structurally):
- Enactment, Citation, Commencement
- Interpretation, Definition
- Application, Scope
- Process, Rule, Constraint, Condition
- Amendment
- Repeal, Revocation
- Extent, Exemption, Charge/Fee, Power Conferred
- Offence, Enforcement/Prosecution, Defence/Appeal
- Transitional Arrangement

**Obligation tags** (what type of legal obligation exists):
- **Duty** -- obligation on governed entities
- **Right** -- entitlement of governed entities
- **Responsibility** -- obligation on government entities
- **Power** -- discretionary authority for government

These are crammed together in a single Airtable multi-select. A Making law's `duty_type` looks like:

```
Duty,Right,Responsibility,Power,"Enactment, Citation, Commencement",
"Interpretation, Definition","Application, Scope","Process, Rule, Constraint, Condition",
Offence,"Enforcement, Prosecution"
```

### The Perfect Correlation: Function=Making ↔ duty_type has Duty/Responsibility

| | duty_type has Duty or Responsibility | duty_type has neither |
|---|---|---|
| **Function has Making** | **2,989** | 197 |
| **Function set, no Making** | **0** | 9,674 |
| **Function empty** | **0** | 6,713 |

This is almost a perfect 1:1 mapping. **Every record with Duty/Responsibility in its duty_type also has Making in its Function.** Zero exceptions in the other direction. The 197 records with Making but without Duty/Responsibility in duty_type are likely laws where the Purpose tags were populated but the Obligation tags weren't yet filled in.

### Three Completely Different "Role" Vocabularies

There are **three independent role/actor naming systems** in play:

#### 1. Airtable `actor` / `actor_gvt` (the TAXA output stored in Airtable)

Prefixed, hierarchical taxonomy. 80 governed actor tags, 45 government tags:

```
Governed:    Org: Employer, Ind: Person, SC: T&L: Driver, Org: Company, SC: Manufacturer
Government:  Gvt: Minister, Gvt: Authority: Local, Gvt: Agency: HSE, Crown
```

4,986 records have actor data. This is what the `role` column in the SQL dump contains.

#### 2. Airtable `duty_holder` / `power_holder` / `rights_holder` / `responsibility_holder`

**Same vocabulary as actor** (prefixed taxonomy), but filtered by obligation type. A law's `actor` field lists ALL roles found in the text; the holder fields split them by what type of obligation they carry:

```
actor:               Ind: Person, Org: Company, Org: Owner, Public, Spc: Inspector, ...
duty_holder:         Ind: Person                    (only those with DUTIES)
responsibility_hld:  Gvt: Authority: Local          (only those with RESPONSIBILITIES)
power_holder:        Gvt: Minister, Spc: Inspector  (only those with POWERS)
rights_holder:       Ind: Person, Org: Company      (only those with RIGHTS)
```

2,450 records have CSV duty_holder data. 71 distinct tags -- all using the `Org:`, `Ind:`, `SC:`, `Gvt:`, `Spc:` prefix system.

#### 3. The LIVE DB `duty_holder` / `power_holder` / `rights_holder` (taxa parser output)

**Completely different vocabulary** -- plain English, no prefixes:

```
duty_holder:   ["Employer", "Driver", "Person", "Body corporate", "Vehicle keeper", ...]
power_holder:  ["Secretary of State", "Police officer", "Local authority", ...]
rights_holder: ["Driver", "Employer", "Person", "Road user", ...]
```

42 distinct tags. **Zero overlap** with the Airtable holder vocabulary.

### Where the DB Holder Data Actually Came From

The SQL dump (`uk_lrt_data.sql`) has **NULL for all holder fields** in every record. Verified by examining specific records (e.g., "Motor Vehicles (Driving Licences) Regulations 1999" has 55 NULLs and no holder data in the dump, but extensive holder data in the live DB).

The live DB's holder data was written by the **taxa regex parser** (`scraper/taxa_parser.ex`) running against the live database after import. The parser uses its own actor definitions (`taxa/actor_definitions.ex`) which produce plain-English role names like "Employer", "Driver", "Secretary of State" -- not the Airtable prefixed taxonomy.

### The Import Timeline That Created the Muddle

```
1. Airtable is maintained manually for years
   - Function: multi-select (Making, Amending, Amending Maker, ...)
   - duty_type: combined Purpose + Obligation tags
   - actor/duty_holder: prefixed taxonomy (Org: Employer, Ind: Person, ...)

2. Old sertantai DB is built from Airtable exports
   - function column: gets a DIFFERENT text vocabulary (Amendment, Commencement, ...)
   - is_making: numeric(38,9) boolean
   - role column: gets the Airtable actor prefixed taxonomy
   - duty_holder/power_holder/rights_holder: LEFT NULL in the dump

3. pg_dump creates uk_lrt_data.sql from old DB
   - Carries the old function vocabulary (not Airtable's)
   - Carries the role data (Airtable's actor vocabulary)
   - Carries NULL holders

4. sertantai-legal is created with Ash schema
   - function: JSONB map (expects Airtable vocabulary)
   - is_making: boolean
   - duty_holder etc: JSONB

5. import_uk_lrt.sql loads the pg_dump
   - Puts old function vocabulary into JSONB column
   - Puts numeric is_making into boolean column (cast issues)
   - Puts NULL into all holder fields

6. Taxa parser runs against live DB
   - Reads full law text from legislation.gov.uk
   - Writes holder data using its OWN vocabulary (plain English)
   - Overwrites NULL holders with ["Employer", "Driver", ...]

7. update_uk_lrt_function.exs runs (if at all)
   - Overwrites old function values with proper Airtable JSONB
   - Sets is_making boolean correctly
   - Does NOT touch holder fields
```

The result: the DB has a Frankenstein of three vocabularies:
- `function`: either old TEXT or Airtable JSONB (depends on import order)
- `is_making`: either 'Act'/'SI' text or true/false boolean (depends on import order)
- `role`: Airtable prefixed taxonomy (from SQL dump)
- `duty_holder` etc: taxa parser plain-English vocabulary (from regex pipeline)

### The Fix

The Airtable CSV is the single source of truth for:
- `Function` -> `function` JSONB (8-tag taxonomy with Maker qualifiers)
- `duty_type` -> obligation classification (Duty/Right/Responsibility/Power + Purpose)
- `actor` / `actor_gvt` -> role classification (prefixed taxonomy)
- `duty_holder` etc -> holder classification (prefixed taxonomy, filtered by obligation type)

The taxa parser produces an **independent, complementary** classification using its own vocabulary. Both are valid but they should not overwrite each other. The DB needs either:
1. **Separate columns** for Airtable-sourced vs taxa-parser-sourced holder data, OR
2. **One canonical vocabulary** that both systems use (mapping between them), OR
3. **Migration to the Rust/AI service** which replaces both the Airtable manual tagging and the Elixir regex parser with a unified AI-driven classification

For the immediate question of **detecting duty-setting laws**: use `Function` containing `Making` (Airtable source). This is 100% correlated with `duty_type` containing Duty/Responsibility. No full-text parsing needed for the pre-filter.
