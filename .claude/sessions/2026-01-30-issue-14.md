# Issue #14: Schema: Consolidate holder/article columns into JSONB fields

**Started**: 2026-01-30 07:50 UTC
**Issue**: https://github.com/shotleybuilder/sertantai-legal/issues/14

## Todo

### Phase 1: Schema Migration (all 4 holder types) âœ… COMPLETE
- [x] Analyze current duty_holder_article, duty_holder_article_clause, article_duty_holder, article_duty_holder_clause data
- [x] Design JSONB structure for duty_holder_duties
- [x] Create DB migration adding 4 new JSONB columns: `duties`, `rights`, `responsibilities`, `powers`
- [x] Create data migration script (`scripts/data/migrate_holder_columns_to_jsonb.exs`) to transform existing text â†’ JSONB
- [x] Test PostgreSQL JSONB queries against migrated data
- [x] Backup DB to ~/Documents/sertantai-data

#### Phase 1 Results
| Metric | Value |
|--------|-------|
| Records with duties | 2,430 |
| Records with rights | 1,812 |
| Records with responsibilities | 2,513 |
| Records with powers | 2,121 |
| **Old 16 columns storage** | **78 MB** |
| **New 4 columns storage** | **5.6 MB** |
| **Storage reduction** | **93%** |

Backup: `~/Documents/sertantai-data/sertantai_legal_dev_20260130_173734.sql`

### Phase 2a: TaxaFormatter Layer (Low Risk) âœ… COMPLETE
- [x] Create TaxaFormatter module (parses existing text â†’ JSONB)
- [x] Update TaxaParser to dual-write (text + JSONB)
- [x] Validate JSONB matches Phase 1 migrated data (2,430/2,430 duties match)
- [x] Validate rights, responsibilities, powers match migrated data
- [x] Add JSONB fields to ParsedLaw struct (type spec, defstruct, from_map)

#### Phase 2a Validation Results
| Holder Type | Records | Match |
|-------------|---------|-------|
| duties | 2,430 | 100% |
| rights | 1,812 | 100% |
| responsibilities | 2,513 | 100% |
| powers | 2,121 | 100% |

#### ParsedLaw Integration
The JSONB fields now persist correctly through the full parse â†’ save flow:
1. TaxaParser returns `duties`, `rights`, `responsibilities`, `powers` fields
2. ParsedLaw.from_map() captures them via `get_map/2` helper
3. ParsedLaw.to_db_attrs() includes them in the output map
4. Persister saves them to the database

Commits:
- `0f473e8` - Phase 2a: Extend TaxaFormatter to all holder types (duties, rights, responsibilities, powers)
- `362bbca` - fix(parsed_law): Add JSONB holder fields to ParsedLaw struct

### Phase 2b: DutyTypeLib Optimization (After 2a Proven) âœ… COMPLETE
- [x] Create TDD tests for Phase 2b (27 tests covering structured data contract)
- [x] Refactor DutyTypeLib to return structured match data
- [x] Add matches_to_jsonb functions to TaxaFormatter
- [x] Update DutyType to produce both legacy text AND JSONB directly
- [x] Update TaxaParser to pass through JSONB from DutyType (no text parsing)

#### Phase 2b Architecture Changes
**Before (Phase 2a):**
```
DutyTypeLib.find_role_holders()
  â†’ returns {holders, duty_types, emoji_text_string, regexes}

DutyType.process_record()
  â†’ stores emoji_text_string as duty_holder_article_clause

TaxaParser.classify_text()
  â†’ calls TaxaFormatter.duties_to_jsonb(emoji_text) to parse text â†’ JSONB
```

**After (Phase 2b):**
```
DutyTypeLib.find_role_holders()
  â†’ returns {holders, duty_types, [%{holder, duty_type, clause}], regexes}
  â†’ BREAKING CHANGE: now returns list of structured maps

DutyType.process_record()
  â†’ generates legacy text via matches_to_legacy_text/1
  â†’ generates JSONB via TaxaFormatter.duties_from_matches/1
  â†’ stores BOTH for backwards compatibility

TaxaParser.classify_text()
  â†’ passes through JSONB from DutyType (no parsing needed)
```

#### Benefits
- Eliminates text parsing overhead in TaxaFormatter
- JSONB generation is now direct from match data
- Legacy text format preserved for backwards compatibility
- Type-safe structured data flow

Commits:
- `84d257a` - feat(phase2b): Refactor DutyTypeLib to return structured match data

## Phase 2 Architecture Recommendation

### Current Flow (Tightly Coupled)
```
DutyTypeLib.find_role_holders()
  â†’ returns {holders, duty_types, matches_string, regexes}
  â†’ matches_string is newline-joined text with emojis

DutyType.process_record()
  â†’ stores matches_string as duty_holder_article_clause (text)

TaxaParser.classify_text()
  â†’ returns duty_holder_article_clause directly
  â†’ ParsedLaw stores as text column
```

### Problem
- String formatting (emojis, newlines) is embedded in DutyTypeLib
- No clean way to produce JSONB without changing core parsing logic
- Parsing is complex and optimized (modal windowing, parallel chunking)

### Recommended Solution: TaxaFormatter Module

Create a **serializer layer** that transforms raw parsing results into output formats:

```
DutyTypeLib.find_role_holders()
  â†’ returns {holders, duty_types, raw_matches, regexes}
  â†’ raw_matches is list of structured match data

DutyType.process_record()
  â†’ stores raw_matches as duty_holder_matches (list of maps)

TaxaParser.classify_text()
  â†’ returns raw structured data

TaxaFormatter.to_jsonb(taxa_result)      â†’ new JSONB format
TaxaFormatter.to_legacy_text(taxa_result) â†’ old text format (for migration period)
```

### Raw Match Structure (from DutyTypeLib)
```elixir
%{
  holder: "Ind: Person",
  article_url: "https://legislation.gov.uk/uksi/2005/621/regulation/4",
  duty_type: "DUTY",
  clause_snippet: "applicant as two or more farming businesses..."
}
```

### TaxaFormatter Module
```elixir
defmodule SertantaiLegal.Legal.Taxa.TaxaFormatter do
  @moduledoc """
  Serializes TaxaParser results into various output formats.
  Decouples parsing logic from output format concerns.
  """

  @doc """
  Convert raw taxa results to new JSONB format.
  """
  def to_duties_jsonb(matches, law_name) do
    entries = Enum.map(matches, fn match ->
      %{
        "holder" => match.holder,
        "article" => extract_article_path(match.article_url, law_name),
        "duty_type" => match.duty_type,
        "clause" => match.clause_snippet
      }
    end)

    %{
      "entries" => entries,
      "holders" => entries |> Enum.map(& &1["holder"]) |> Enum.uniq() |> Enum.sort(),
      "articles" => entries |> Enum.map(& &1["article"]) |> Enum.uniq() |> Enum.sort()
    }
  end

  @doc """
  Convert raw taxa results to legacy text format (backwards compatibility).
  """
  def to_legacy_text(matches) do
    # Produces: "[Holder]\nURL\nDUTY\nðŸ‘¤Holder\nðŸ“Œclause\n\n[Holder2]..."
  end

  defp extract_article_path(url, law_name) do
    # "https://legislation.gov.uk/uksi/2005/621/regulation/4" â†’ "regulation/4"
  end
end
```

### Implementation Strategy: Two-Phase Approach

#### Phase 2a: Formatter Layer (Low Risk)
1. **Create TaxaFormatter** - Parse existing text output into structured data
2. **Dual-write** - TaxaParser writes both old text AND new JSONB (via formatter)
3. **Validate** - Confirm JSONB matches migrated data from Phase 1
4. **Frontend update** - Switch to consuming JSONB

```
DutyTypeLib.find_role_holders()
  â†’ returns matches_string (unchanged)

TaxaParser.classify_text()
  â†’ returns duty_holder_article_clause (text, unchanged)

TaxaFormatter.text_to_jsonb(text, law_name)  â† NEW: parses text â†’ JSONB
  â†’ produces duties JSONB

ParsedLaw stores BOTH:
  - duty_holder_article_clause (text) - legacy
  - duties (jsonb) - new
```

**Why this approach:**
- Zero changes to DutyTypeLib (complex, optimized, risky to modify)
- Formatter parses the already-working text output
- Easy to validate: JSONB from formatter should match Phase 1 migration
- If something breaks, old text columns still work

#### Phase 2b: DutyTypeLib Optimization (After Proven)
Once dual-write is validated and frontend uses JSONB:

1. **Refactor DutyTypeLib** - Return structured match data directly
2. **Simplify TaxaFormatter** - No longer needs to parse text
3. **Remove legacy text generation** - DutyTypeLib stops building strings
4. **Drop old columns** - Final cleanup

```
DutyTypeLib.find_role_holders()
  â†’ returns raw_matches (list of maps)  â† CHANGED

TaxaFormatter.matches_to_jsonb(matches, law_name)
  â†’ produces duties JSONB directly (no parsing)

ParsedLaw stores ONLY:
  - duties (jsonb)
```

**Why wait for Phase 2b:**
- DutyTypeLib has complex regex logic, modal windowing, parallel chunking
- String formatting is interleaved with match detection
- Refactoring while maintaining backwards compat is risky
- Once JSONB is proven, we can safely refactor without fallback

### Risk Comparison

| Approach | Risk | Rollback |
|----------|------|----------|
| Phase 2a (parse text â†’ JSONB) | Low | Drop JSONB column, keep text |
| Phase 2b (refactor DutyTypeLib) | Medium | Harder - parsing logic changed |
| Direct refactor (skip 2a) | High | Very hard - no fallback |

### Benefits of Two-Phase
- **Incremental validation** - Each phase can be tested independently
- **Safe rollback** - Phase 2a has full rollback path
- **Proven before optimized** - Only refactor DutyTypeLib after JSONB is working
- **Parallel work** - Frontend can start using JSONB while 2b is developed

### Phase 3: Frontend Update âœ… COMPLETE
**Goal**: Expose new JSONB fields (`duties`, `rights`, `responsibilities`, `powers`) and remove deprecated 16 text columns.

#### 3.1 TypeScript Schema Update âœ…
- [x] Add new JSONB fields to `UkLrtRecord` interface (`uk-lrt-schema.ts`)
  - `duties: HolderJsonb | null`
  - `rights: HolderJsonb | null`
  - `responsibilities: HolderJsonb | null`
  - `powers: HolderJsonb | null`
- [x] Add `HolderEntry` and `HolderJsonb` type definitions for JSONB structure
- [x] Add `parseHolderJsonb()` function to transform raw JSONB
- [x] Update `transformUkLrtRecord()` to parse new fields
- [x] Remove deprecated text columns from interface (16 columns)

#### 3.2 ElectricSQL Sync Update âœ…
- [x] Add new JSONB columns to `UK_LRT_COLUMNS` array (`sync-uk-lrt.ts`)
- [x] Remove deprecated text columns from `UK_LRT_COLUMNS`
- [x] Update `db/index.client.ts` UK_LRT_COLUMNS array

#### 3.3 Field Config Update âœ…
- [x] Update `field-config.ts` with new JSONB field labels
- [x] Remove deprecated field labels
- [x] Update stage 7 (Taxa) subsections to use new fields

#### 3.4 RecordDiff Update âœ…
- [x] Update `RecordDiff.svelte` Roles category with new fields
- [x] Remove deprecated fields from Roles grouping

#### 3.5 Admin Table Update âœ…
- [x] Update `+page.svelte` column groups (consolidated from 4 detailed groups to 4 simplified)
- [x] Update column definitions with JSONB cell renderers
- [x] Remove deprecated column definitions

#### 3.6 ParseReviewModal Update âœ…
- [x] ParseReviewModal uses `SECTION_CONFIG` from field-config.ts (already updated)
- [x] Taxa section now displays new JSONB fields via updated field config

#### 3.7 URL Reconstruction Helper (Deferred)
- [ ] Add `buildArticleUrl(lawName, articlePath)` utility function
- [ ] Use in JSONB entry display to make article paths clickable
- **Note**: Deferred to Phase 4 - basic functionality complete without clickable URLs

#### Phase 3 Files Changed
| File | Changes |
|------|---------|
| `uk-lrt-schema.ts` | +HolderEntry, +HolderJsonb interfaces, +parseHolderJsonb(), -16 deprecated fields |
| `sync-uk-lrt.ts` | +4 JSONB columns, -16 deprecated columns |
| `db/index.client.ts` | +4 JSONB columns, -16 deprecated columns |
| `field-config.ts` | Updated labels, simplified subsections |
| `RecordDiff.svelte` | Updated Roles category |
| `+page.svelte` | Updated column groups and definitions |
| `uk-lrt-schema.test.ts` | Updated tests for new JSONB structure |

**Net code reduction**: 212 lines removed (436 deletions, 224 additions)

Commits:
- `f6162dc` - feat(phase3): Frontend update - expose JSONB holder fields, remove 16 deprecated columns

### Phase 4: Cleanup âœ… COMPLETE
**Goal**: Drop deprecated columns, add indexes, clean up backend code.

#### 4.1 Database Migration âœ…
- [x] Created migration `20260130185806_phase4_holder_jsonb_indexes_and_cleanup.exs`
- [x] Added GIN indexes on JSONB `holders` arrays for efficient querying:
  - `uk_lrt_duties_holders_gin`
  - `uk_lrt_rights_holders_gin`
  - `uk_lrt_responsibilities_holders_gin`
  - `uk_lrt_powers_holders_gin`
- [x] Dropped 16 deprecated text columns from database

#### 4.2 Backend Code Cleanup âœ…
- [x] Removed 16 deprecated attributes from UkLrt Ash resource
- [x] Updated `accept` lists in UkLrt create/update actions
- [x] Removed deprecated fields from ParsedLaw struct (type spec, defstruct, from_map)
- [x] Updated TaxaParser to only output JSONB fields (removed legacy text output)
- [x] Removed `matches_to_legacy_text/1` from DutyType (no longer needed)
- [x] Updated DutyType docstring

#### 4.3 URL Reconstruction Helper (Deferred)
- [ ] Add `buildArticleUrl(lawName, articlePath)` utility function
- [ ] Use in JSONB entry display to make article paths clickable
- **Note**: Deferred - basic functionality complete without clickable URLs

#### Phase 4 Files Changed
| File | Changes |
|------|---------|
| `phase4_holder_jsonb_indexes_and_cleanup.exs` | New migration |
| `uk_lrt.ex` | -84 lines (attributes, accept lists) |
| `parsed_law.ex` | -51 lines (type spec, defstruct, from_map) |
| `taxa_parser.ex` | -7 lines (legacy text output) |
| `duty_type.ex` | -27 lines (legacy text functions, docstring) |

**Net backend code reduction**: 193 lines removed (214 deletions, 21 additions)

Commits:
- `7c78cee` - feat(phase4): Drop deprecated holder columns, add GIN indexes

### Phase 5: Manual Testing & Bug Fixes âœ… COMPLETE
**Goal**: Verify functionality and fix any issues found during manual testing.

#### 5.1 Bug: Article field not populating in JSONB entries âœ… FIXED
- [x] **Issue**: All `article` fields in duties/rights/responsibilities/powers JSONB entries are `null`
- [x] **Initial Investigation**: Identified that P1 section_ids weren't being passed to DutyType
- [x] **Initial Fix (partial)**: Updated DutyType to accept `article:` keyword argument
- [x] **Root Cause**: In chunked processing path, result map was getting JSONB fields from `merged_record` (which didn't have them) instead of `duty_type_results`
- [x] **Complete Fix**: Changed `taxa_parser.ex` lines 423-427 to get JSONB fields from `duty_type_results`:
  ```elixir
  # BEFORE (BUG):
  duties: Map.get(merged_record, :duties),
  
  # AFTER (FIXED):
  duties: duty_type_results.duties,
  ```
- [x] **Regression Test**: Added comprehensive tests in `taxa_parser_test.exs`:
  - `JSONB holder fields contain article from section_id (regression for Issue #14 bug)`
  - `JSONB fields merge articles from multiple sections for same holder`

**Files Changed**:
| File | Changes |
|------|---------|
| `duty_type.ex` | Accept optional `article:` keyword argument |
| `taxa_parser.ex` | Pass section_id as article; get JSONB from duty_type_results not merged_record |
| `taxa_parser_test.exs` | +2 regression tests for JSONB article field population |

**Test Results**: 697 tests, 0 failures

Commits:
- `2d67f02` - fix(phase5): Populate article field in JSONB holder entries (partial fix)
- `1a97ae1` - fix(phase5): Fix JSONB fields in chunked path + regression tests (chunked path fix)
- `9156918` - fix(phase5): Extract P1 sections for all laws to populate article field (complete fix)

#### 5.2 Bug: Article field null for small laws âœ… FIXED
- [x] **Issue**: Small laws (under 200k chars) weren't getting P1 sections extracted, so article fields were null
- [x] **Root Cause**: P1 section extraction was conditional on `large_law?()` check
- [x] **Fix**: Changed `fetch_body_text/3` to always extract P1 sections regardless of law size
- [x] **Result**: All laws with P1 tags now populate article fields

**Test Results**: 697 tests, 0 failures

---

## Issue #14 Summary

### Total Impact
| Metric | Before | After | Change |
|--------|--------|-------|--------|
| Database columns | 20 (4 JSONB + 16 text) | 4 JSONB | -16 columns |
| Storage (holder data) | 78 MB | 5.6 MB | **-93%** |
| Backend code lines | - | - | **-193 lines** |
| Frontend code lines | - | - | **-212 lines** |
| Tests | 695 | 695 | All pass |

### All Commits
1. Phase 1: `(earlier)` - Schema migration, data migration script
2. Phase 2a: `0f473e8` - TaxaFormatter layer for dual-write
3. Phase 2a: `362bbca` - Add JSONB holder fields to ParsedLaw struct
4. Phase 2b: `84d257a` - Refactor DutyTypeLib to return structured match data
5. Phase 3: `f6162dc` - Frontend update - expose JSONB holder fields
6. Phase 4: `7c78cee` - Drop deprecated holder columns, add GIN indexes

## Analysis Findings (Phase 1)

### Current Schema
| Column | Type | Purpose |
|--------|------|---------|
| `duty_holder` | jsonb | Simple map: `{"Ind: Person": true, "Org: Employer": true}` |
| `duty_holder_article` | text | Newline-separated: `[Holder]\nURL\nURL\n\n[Holder2]\nURL` |
| `duty_holder_article_clause` | text | Same format + duty type + clause text |
| `article_duty_holder` | text | Inverse: `URL\nHolder; Holder2\n\nURL2\nHolder` |
| `article_duty_holder_clause` | text | Same format + clause details |

### Data Statistics
| Metric | Value |
|--------|-------|
| Total records | 19,091 |
| Records with duty data | 2,430 (12.7%) |
| Unique duty holders | 72 |
| Top holder | "Ind: Person" (1,941 occurrences) |

### Storage (Duty Holder columns only)
| Column | Size |
|--------|------|
| duty_holder_article | 1.2 MB |
| duty_holder_article_clause | 5.1 MB |
| article_duty_holder | 3.0 MB |
| article_duty_holder_clause | 13 MB |
| **Total** | **22 MB** |

### Max Field Sizes
| Column | Avg Length | Max Length |
|--------|------------|------------|
| duty_holder_article | 518 | 10,913 |
| duty_holder_article_clause | 2,164 | 46,640 |
| article_duty_holder | 1,282 | 31,659 |
| article_duty_holder_clause | 5,543 | 95,760 |

### Data Format Pattern
```
[Holder Category: Name]
https://legislation.gov.uk/type/year/number/article
https://legislation.gov.uk/type/year/number/article2

[Another Holder]
https://legislation.gov.uk/type/year/number/article3
```

Clause versions add duty type and text snippets with emojis.

### Key Observations
1. Data is text with newline-separated blocks, not JSON/JSONB
2. High redundancy - same info stored in 4 different orientations
3. Clause versions are ~4x larger than non-clause versions
4. 22 MB total for duty_holder Ã— 4 holder types = ~88 MB potential savings
5. Existing `duty_holder` JSONB is just a boolean presence map

---

## Proposed JSONB Schema: `duty_holder_duties`

### Design Principles
1. **Single source of truth** - store data once, derive orientations via queries
2. **URL optimization** - store only article path, not full URL (law identity is known)
3. **No emojis** - add presentation layer in frontend
4. **Flat entries array** - enables flexible grouping/filtering

### Schema

```json
{
  "entries": [
    {
      "holder": "Ind: Applicant",
      "article": "regulation/4",
      "duty_type": "DUTY",
      "clause": "applicant as two or more farming businesses in order to comply..."
    },
    {
      "holder": "Org: Company",
      "article": "regulation/4",
      "duty_type": "DUTY",
      "clause": "business but is instead farmed by the applicant..."
    },
    {
      "holder": "Ind: Person",
      "article": "regulation/16",
      "duty_type": "DUTY",
      "clause": null
    }
  ],
  "holders": ["Ind: Applicant", "Org: Company", "Ind: Person"],
  "articles": ["regulation/4", "regulation/16"]
}
```

### Field Descriptions

| Field | Type | Description |
|-------|------|-------------|
| `entries` | array | Core data - one entry per holder/article/clause combination |
| `entries[].holder` | string | Duty holder identifier (e.g., "Ind: Person", "Org: Employer") |
| `entries[].article` | string | Article path only (e.g., "regulation/4", "crossheading/applications-for-grant") |
| `entries[].duty_type` | string | Type of duty (e.g., "DUTY", "RIGHT", "POWER") |
| `entries[].clause` | string\|null | Clause text snippet (null if no clause-level detail) |
| `holders` | array | Deduplicated list of all holders (for quick filtering) |
| `articles` | array | Deduplicated list of all articles (for quick filtering) |

### URL Reconstruction

Full URL can be reconstructed from law name + article path:

```
Law name: UK_uksi_2005_621
Article: regulation/4
â†’ https://legislation.gov.uk/uksi/2005/621/regulation/4
```

Frontend helper:
```javascript
function buildArticleUrl(lawName, articlePath) {
  // UK_uksi_2005_621 â†’ uksi/2005/621
  const [_, type, year, number] = lawName.split('_');
  return `https://legislation.gov.uk/${type}/${year}/${number}/${articlePath}`;
}
```

### Query Examples

**Get all entries (replaces all 4 columns):**
```sql
SELECT duty_holder_duties->'entries' FROM uk_lrt WHERE name = 'UK_uksi_2005_621';
```

**Group by holder (replaces duty_holder_article):**
```sql
SELECT 
  entry->>'holder' as holder,
  jsonb_agg(entry->>'article') as articles
FROM uk_lrt, jsonb_array_elements(duty_holder_duties->'entries') as entry
WHERE name = 'UK_uksi_2005_621'
GROUP BY entry->>'holder';
```

**Group by article (replaces article_duty_holder):**
```sql
SELECT 
  entry->>'article' as article,
  jsonb_agg(entry->>'holder') as holders
FROM uk_lrt, jsonb_array_elements(duty_holder_duties->'entries') as entry
WHERE name = 'UK_uksi_2005_621'
GROUP BY entry->>'article';
```

**Filter by holder:**
```sql
SELECT * FROM uk_lrt 
WHERE duty_holder_duties->'holders' ? 'Ind: Person';
```

**Filter by article:**
```sql
SELECT * FROM uk_lrt 
WHERE duty_holder_duties->'articles' ? 'regulation/4';
```

**With clause detail (replaces *_clause columns):**
```sql
SELECT entry->>'holder', entry->>'article', entry->>'clause'
FROM uk_lrt, jsonb_array_elements(duty_holder_duties->'entries') as entry
WHERE name = 'UK_uksi_2005_621'
AND entry->>'clause' IS NOT NULL;
```

**Without clause detail:**
```sql
SELECT DISTINCT entry->>'holder', entry->>'article'
FROM uk_lrt, jsonb_array_elements(duty_holder_duties->'entries') as entry
WHERE name = 'UK_uksi_2005_621';
```

### Indexing Strategy

```sql
-- GIN index for holder/article containment queries
CREATE INDEX idx_duty_holder_duties_holders ON uk_lrt USING GIN ((duty_holder_duties->'holders'));
CREATE INDEX idx_duty_holder_duties_articles ON uk_lrt USING GIN ((duty_holder_duties->'articles'));

-- Optional: full entries index for complex queries
CREATE INDEX idx_duty_holder_duties_entries ON uk_lrt USING GIN ((duty_holder_duties->'entries'));
```

### Storage Estimate

| Current | Proposed |
|---------|----------|
| 4 text columns with redundant data | 1 JSONB column with normalized data |
| ~22 MB | ~5-8 MB estimated (no URL redundancy, no duplicate orientations) |

### Columns to Deprecate (Phase 1)

After migration, these columns can be removed:
- `duty_holder_article`
- `duty_holder_article_clause`
- `article_duty_holder`
- `article_duty_holder_clause`

The existing `duty_holder` JSONB can remain as a quick boolean lookup, or be derived from `duty_holder_duties->'holders'`.

## Notes
- Consolidate 16 columns â†’ 4 JSONB columns
- Phase 1 proves the pattern, Phases 2-4 are rinse and repeat
- Consider GIN indexes for JSONB querying
- Current text format will need parsing for migration

**Ended**: 2026-01-31 21:06 UTC
